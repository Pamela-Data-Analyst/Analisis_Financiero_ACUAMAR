# -*- coding: utf-8 -*-
"""financiero_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GI5mehsXneZldXMBRtaXaXsuz8gu6HOd
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from prophet import Prophet

# --- CONSTANTES CODIFICADAS --- (Aseg煤rate de que estas coincidan con tus valores originales)
UMBRAL_LIQUIDEZ_MINIMA = 0.0
TASA_IVA_GENERAL = 0.19
TASA_IMPUESTO_RENTA = 0.35
TASA_RETENCION_FUENTE = 0.025
TASA_ROTACION_CARTERA_DIAS = 30
HORIZONTE_PROYECCION = 12
NUM_SIMULACIONES = 1000 # Reducido para una demostraci贸n m谩s r谩pida, se puede aumentar a 5000

# --- T铆tulo y Configuraci贸n de la Aplicaci贸n Streamlit ---
st.set_page_config(layout="wide", page_title="An谩lisis Financiero ACUAMAR S.A.")
st.title(" An谩lisis Financiero y de Riesgos - ACUAMAR S.A.")
st.write("Esta aplicaci贸n proporciona un an谩lisis completo de la salud financiera de la empresa, incluyendo indicadores hist贸ricos, proyecciones de flujo de caja e impuestos, y una simulaci贸n de riesgo financiero mediante Monte Carlo.")

# --- Carga de Datos --- (Usamos cach茅 para cargar los datos una sola vez)
@st.cache_data
def load_data():
    try:
        # Aseg煤rate de que 'Datos_Financieros_Comerciales.xlsx' est茅 en la misma carpeta
        df_fin = pd.read_excel('Datos_Financieros_Comerciales.xlsx', sheet_name='financiero')
        # Conversi贸n de tipos y limpieza de datos inicial
        if not df_fin.empty:
            df_fin['FECHA'] = pd.to_datetime(df_fin['FECHA'], errors='coerce')
            # Usar 'ME' para el final del mes, para evitar deprecation warning
            df_fin_mensual = df_fin.dropna(subset=['FECHA']).sort_values('FECHA').set_index('FECHA').resample('ME').last()
            df_fin_mensual = df_fin_mensual.dropna(how='all')
        return df_fin, df_fin_mensual
    except FileNotFoundError:
        st.error("隆Error! El archivo 'Datos_Financieros_Comerciales.xlsx' no fue encontrado. Aseg煤rese de que el archivo Excel est茅 en la misma carpeta que la aplicaci贸n Streamlit.")
        st.stop()
    except Exception as e:
        st.error(f"Error al cargar o procesar los datos: {e}")
        st.stop()

df_fin, df_fin_mensual = load_data()

# --- Funciones de Modelado (Prophet) --- (Usamos cach茅 para que el modelo se entrene una sola vez)
@st.cache_resource
def fit_and_predict_prophet(series, horizon):
    """Aplica Prophet a una serie de tiempo y devuelve las predicciones."""
    df_prophet = series.reset_index().rename(columns={'FECHA': 'ds', series.name: 'y'})
    m = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=True, interval_width=0.95)
    m.fit(df_prophet)
    future = m.make_future_dataframe(periods=horizon, freq='M')
    forecast = m.predict(future)
    forecast_future = forecast[forecast['ds'] > series.index.max()].set_index('ds')
    std_dev = (forecast_future['yhat_upper'] - forecast_future['yhat_lower']) / 2
    return forecast_future['yhat'], std_dev.rename('std_dev')

# --- 1. EDA DASHBOARD Y ALERTAS DE LIQUIDEZ ---
st.header(" 1. Dashboard de EDA y Alertas de Liquidez")

# CLCULO DE KPIS HISTRICOS
df_fin['Capital_Trabajo_Neto'] = df_fin['Cobros_Clientes'] - df_fin['Pagos_Proveedores']
df_fin['Margen_Bruto_Aprox'] = (df_fin['Ventas_Gravadas'] - df_fin['Pagos_Proveedores']) / df_fin['Ventas_Gravadas']
DIAS_CARTERA_PROMEDIO = df_fin['Ventas_Gravadas'].rolling(window=3).mean().mean() / df_fin['Cobros_Clientes'].mean() * TASA_ROTACION_CARTERA_DIAS

st.subheader("Tarjetas de KPI (Valores Recientes)")
col1, col2, col3 = st.columns(3)
with col1:
    st.metric("D铆as de Cartera Promedio", f"{DIAS_CARTERA_PROMEDIO:.0f} d铆as", help=f"Salud de cobros (comparar con {TASA_ROTACION_CARTERA_DIAS} d铆as)")
with col2:
    st.metric("Capital de Trabajo Neto", f"{df_fin['Capital_Trabajo_Neto'].iloc[-1]:,.0f} COP", help="Capacidad de cubrir pasivos a corto plazo")
with col3:
    st.metric("Margen Bruto (%) (Aprox)", f"{df_fin['Margen_Bruto_Aprox'].iloc[-1]*100:.2f}%", help="Eficiencia en el flujo de caja operativo")

st.subheader("Tendencia Hist贸rica de Cobros vs. Pagos")
fig_tendencia_caja = px.line(df_fin, x='FECHA', y=['Cobros_Clientes', 'Pagos_Proveedores'],
                             title='Cobros vs. Pagos: Identificaci贸n de Descalces Hist贸ricos',
                             labels={'value': 'Monto (COP)', 'FECHA': 'Fecha'},
                             color_discrete_map={'Cobros_Clientes': 'green', 'Pagos_Proveedores': 'red'})
st.plotly_chart(fig_tendencia_caja, use_container_width=True)


# --- 2. FLUJO DE CAJA PROYECTADO Y CONTROL DE IMPUESTOS ---
st.header(" 2. Flujo de Caja Proyectado y Control de Impuestos")

st.subheader("Predicci贸n Base (Prophet)")
with st.spinner(f"Calculando predicciones a {HORIZONTE_PROYECCION} meses con Prophet..."):
    pred_cobros, std_cobros = fit_and_predict_prophet(df_fin_mensual['Cobros_Clientes'], HORIZONTE_PROYECCION)
    pred_pagos, _ = fit_and_predict_prophet(df_fin_mensual['Pagos_Proveedores'], HORIZONTE_PROYECCION)
    pred_ventas_gravadas, _ = fit_and_predict_prophet(df_fin_mensual['Ventas_Gravadas'], HORIZONTE_PROYECCION)
    pred_gasto_nomina, _ = fit_and_predict_prophet(df_fin_mensual['Gasto_Nomina'], HORIZONTE_PROYECCION)
    pred_base_retencion, _ = fit_and_predict_prophet(df_fin_mensual['Base_Retencion'], HORIZONTE_PROYECCION)
    pred_gastos_gravados, _ = fit_and_predict_prophet(df_fin_mensual['Gastos_Gravados'], HORIZONTE_PROYECCION)

# CLCULO PROYECTADO: Flujo de Caja Neto
df_proj = pd.DataFrame({
    'Cobros_Proyectados': pred_cobros.values,
    'Pagos_Proyectados': pred_pagos.values,
}, index=pred_cobros.index)
df_proj['Flujo_Neto_Proyectado'] = df_proj['Cobros_Proyectados'] - df_proj['Pagos_Proyectados']
efectivo_inicial_actual = df_fin_mensual['Efectivo_Inicial'].iloc[-1]
df_proj['Flujo_Acumulado'] = (df_proj['Flujo_Neto_Proyectado'].cumsum() + efectivo_inicial_actual)

# CLCULO DE IMPUESTOS
df_proj['Proyeccion_IVA'] = (pred_ventas_gravadas - pred_gastos_gravados) * TASA_IVA_GENERAL
df_proj['Proyeccion_Retencion_Fuente'] = pred_base_retencion * TASA_RETENCION_FUENTE
df_proj['Proyeccion_Impuesto_Renta'] = (df_proj['Flujo_Neto_Proyectado'] * TASA_IMPUESTO_RENTA) / 12 # Asumiendo provisi贸n mensual
df_proj['Obligaciones_Fiscales_Totales'] = df_proj['Proyeccion_IVA'] + df_proj['Proyeccion_Retencion_Fuente'] + df_proj['Proyeccion_Impuesto_Renta']

st.subheader("Flujo de Caja Proyectado (Entradas vs. Salidas)")
fig_flujo_area = go.Figure()
fig_flujo_area.add_trace(go.Scatter(x=df_proj.index, y=df_proj['Cobros_Proyectados'].cumsum(),
                                    fill='tozeroy', mode='lines', name='Entradas Acumuladas (Cobros)',
                                    line_color='green'))
fig_flujo_area.add_trace(go.Scatter(x=df_proj.index, y=df_proj['Pagos_Proyectados'].cumsum(),
                                    fill='tozeroy', mode='lines', name='Salidas Acumuladas (Pagos)',
                                    line_color='red'))
fig_flujo_area.update_layout(title=f'Flujo de Caja Proyectado (Entradas vs. Salidas a {HORIZONTE_PROYECCION} meses)',
                              xaxis_title='Fecha de Proyecci贸n',
                              yaxis_title='Monto Acumulado (COP)')
st.plotly_chart(fig_flujo_area, use_container_width=True)

st.subheader("Alertas de Liquidez: Flujo de Caja Acumulado Proyectado")
fig_alerta = px.line(df_proj.reset_index(), x='ds', y='Flujo_Acumulado',
                    title='Alerta de Liquidez: Flujo de Caja Acumulado Proyectado',
                    labels={'ds': 'Fecha', 'Flujo_Acumulado': 'Flujo Neto Acumulado (COP)'})
fig_alerta.add_hline(y=UMBRAL_LIQUIDEZ_MINIMA, line_dash="dash", line_color="red",
                     annotation_text=f"Umbral de Liquidez M铆nima ({UMBRAL_LIQUIDEZ_MINIMA:,.0f} COP)",
                     annotation_position="top right")
puntos_alerta = df_proj[df_proj['Flujo_Acumulado'] < UMBRAL_LIQUIDEZ_MINIMA].index
if not puntos_alerta.empty:
    fig_alerta.add_trace(go.Scatter(x=puntos_alerta, y=df_proj.loc[puntos_alerta, 'Flujo_Acumulado'],
                                    mode='markers', name='Riesgo de Liquidez',
                                    marker=dict(color='red', size=10)))
st.plotly_chart(fig_alerta, use_container_width=True)

st.subheader("Proyecci贸n de Obligaciones Fiscales")
df_impuestos_plot = df_proj[['Proyeccion_IVA', 'Proyeccion_Retencion_Fuente', 'Proyeccion_Impuesto_Renta']].reset_index().rename(columns={'ds': 'Fecha'})
fig_impuestos = px.bar(df_impuestos_plot, x='Fecha',
                       y=['Proyeccion_IVA', 'Proyeccion_Retencion_Fuente', 'Proyeccion_Impuesto_Renta'],
                       title='Proyecci贸n de Obligaciones Fiscales (IVA, Retenci贸n, Renta)',
                       labels={'value': 'Monto Proyectado (COP)', 'variable': 'Tipo de Impuesto'})
fig_impuestos.update_layout(xaxis_tickangle=-45)
st.plotly_chart(fig_impuestos, use_container_width=True)


# --- 3. PREDICCIN DE RIESGOS FINANCIEROS (Monte Carlo) ---
st.header(" 3. Predicci贸n de Riesgos Financieros (Monte Carlo)")

with st.spinner(f"Ejecutando {NUM_SIMULACIONES} simulaciones de Monte Carlo..."):
    # Par谩metros de la simulaci贸n
    sigma_cobros = std_cobros.mean() # Volatilidad: Usamos la desviaci贸n est谩ndar promedio de los cobros proyectados
    pagos_proyectados_media = df_proj['Pagos_Proyectados'].values

    # Almacenar谩 los resultados acumulados de cada simulaci贸n
    resultados_acumulados = []

    for i in range(NUM_SIMULACIONES):
        cobros_simulados = pred_cobros.values + np.random.normal(0, sigma_cobros, size=HORIZONTE_PROYECCION)
        cobros_simulados[cobros_simulados < 0] = 0 # Asegurar que no haya cobros negativos
        flujo_neto_simulado = cobros_simulados - pagos_proyectados_media
        flujo_acumulado_simulado = np.cumsum(flujo_neto_simulado) + efectivo_inicial_actual
        resultados_acumulados.append(flujo_acumulado_simulado)

    df_sims = pd.DataFrame(np.array(resultados_acumulados).T, index=df_proj.index)

# ANLISIS DE RIESGO
probabilidad_fallo = (df_sims.min(axis=0) < UMBRAL_LIQUIDEZ_MINIMA).sum() / NUM_SIMULACIONES
saldo_final_esperado = df_sims.iloc[-1, :].mean()
saldo_final_percentil_10 = np.percentile(df_sims.iloc[-1, :], 10)

st.subheader("Tarjeta de KPI de Riesgo")
col4, col5, col6 = st.columns(3)
with col4:
    st.metric("Probabilidad de Fallo de Liquidez", f"{probabilidad_fallo:.2%}", help="Riesgo de necesitar financiaci贸n externa")
with col5:
    st.metric("Saldo Final Esperado (Media)", f"{saldo_final_esperado:,.0f} COP", help="Escenario m谩s probable")
with col6:
    st.metric("Saldo Final Pesimista (P10)", f"{saldo_final_percentil_10:,.0f} COP", help="L铆mite inferior de riesgo (10% peor)")


st.subheader("Simulaci贸n de Monte Carlo: Flujo de Caja Acumulado")
fig_sims = go.Figure()
# Trazar 50 l铆neas de ejemplo (Escenario de Banda) para claridad
for col_idx in df_sims.columns[:50]:
    fig_sims.add_trace(go.Scatter(x=df_sims.index, y=df_sims[col_idx], mode='lines',
                                  line=dict(color='rgba(0, 0, 255, 0.1)'), showlegend=False))
# L铆nea del Escenario Promedio
fig_sims.add_trace(go.Scatter(x=df_sims.index, y=df_sims.mean(axis=1), mode='lines',
                              line=dict(color='blue', width=2), name='Media Proyectada'))
# Banda Roja de Umbral
fig_sims.add_hline(y=UMBRAL_LIQUIDEZ_MINIMA, line_dash="dash", line_color="red",
                   annotation_text=f"Umbral de Liquidez M铆nima",
                   annotation_position="top right")
fig_sims.update_layout(title=f'Simulaci贸n de Monte Carlo: Flujo de Caja Acumulado ({NUM_SIMULACIONES} escenarios)',
                        xaxis_title='Fecha de Proyecci贸n',
                        yaxis_title='Flujo Neto Acumulado (COP)')
st.plotly_chart(fig_sims, use_container_width=True)


st.subheader("Histograma de Resultados: Distribuci贸n de Saldos Finales de Caja")
fig_hist = px.histogram(x=df_sims.iloc[-1, :],
                        title='Distribuci贸n de Posibles Saldos Finales de Caja',
                        labels={'x': 'Saldo Final de Caja (COP)', 'y': 'Frecuencia'})
fig_hist.add_vline(x=UMBRAL_LIQUIDEZ_MINIMA, line_dash="dash", line_color="red",
                   annotation_text=f"Umbral de Liquidez M铆nima", annotation_position="top right")
st.plotly_chart(fig_hist, use_container_width=True)

st.markdown("--- tuvo errores, esta es la version corregida ---")
st.markdown("Desarrollado para ACUAMAR S.A. ")